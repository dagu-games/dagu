let pathfinder={findShortestPath:function(start_x,start_y,goal_x,goal_y){let count=0;let location={x:start_x,y:start_y,path:[],status:"Start"};let queue=[location];while(queue.length>0){count++;let currentLocation=queue.shift();for(let i=0;i<4;i++){let newLocation=this.exploreInDirection(currentLocation,i,start_x,start_y,goal_x,goal_y);if(newLocation.status==="Goal"){pathfinder.resetPFVariable();return newLocation.path}else if(newLocation.status==="Valid"){queue.push(newLocation)}}}pathfinder.resetPFVariable();return false},locationStatus:function(x,y,goal_x,goal_y){let map_entry=map.get(x,y);if(map_entry.tile==null){return"Invalid"}else if(x===goal_x&&y===goal_y){return"Goal"}else if(!util.isWalkable(x,y)||map_entry.pf!=null&&map_entry.pf.visited===true){return"Blocked"}else{return"Valid"}},exploreInDirection:function(currentLocation,direction,x1,y1,x2,y2){let newPath=currentLocation.path.slice();newPath.push(direction);let x=currentLocation.x;let y=currentLocation.y;if(direction===0){x++}else if(direction===1){y++}else if(direction===2){x--}else if(direction===3){y--}let newLocation={x:x,y:y,path:newPath,status:"Unknown"};newLocation.status=pathfinder.locationStatus(x,y,x2,y2);if(newLocation.status==="Valid"){map.get(x,y).pf={visited:true}}return newLocation},resetPFVariable:function(){let points=map.getAll();for(let i=0;i<points.length;i++){map.get(points[i].x,points[i].y).pf={visited:false}}}};